/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.21.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.openkruise.agents.client.models;

import java.util.Objects;

import com.google.gson.annotations.SerializedName;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired.
 * This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this
 * field is specified, volume binding will only succeed if the type of the specified object matches some installed
 * volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as
 * such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace
 * isn&#39;t specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value
 * automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef,
 * dataSource isn&#39;t set to the same value and must be empty. There are three important differences between
 * dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef   allows
 * any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping
 * them), dataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. * While
 * dataSource only allows local objects, dataSourceRef allows objects   in any namespaces. (Beta) Using this field
 * requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef
 * requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 */
@ApiModel(
    description = "dataSourceRef specifies the object from which to populate the volume with data, if a non-empty "
        + "volume is desired. This may be any object from a non-empty API group (non core object) or a "
        + "PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type "
        + "of the specified object matches some installed volume populator or dynamic provisioner. This field will "
        + "replace the functionality of the dataSource field and as such if both fields are non-empty, they must have"
        + " the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields"
        + " (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and "
        + "the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same "
        + "value and must be empty. There are three important differences between dataSource and dataSourceRef: * "
        + "While dataSource only allows two specific types of objects, dataSourceRef   allows any non-core object, as"
        + " well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), "
        + "dataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. * While"
        + " dataSource only allows local objects, dataSourceRef allows objects   in any namespaces. (Beta) Using this"
        + " field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of "
        + "dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen",
    date = "2026-01-23T10:04:45.718Z[Etc/UTC]")
public class V1alpha1SandboxSetSpecSpecDataSourceRef {
    public static final String SERIALIZED_NAME_API_GROUP = "apiGroup";
    @SerializedName(SERIALIZED_NAME_API_GROUP)
    private String apiGroup;

    public static final String SERIALIZED_NAME_KIND = "kind";
    @SerializedName(SERIALIZED_NAME_KIND)
    private String kind;

    public static final String SERIALIZED_NAME_NAME = "name";
    @SerializedName(SERIALIZED_NAME_NAME)
    private String name;

    public static final String SERIALIZED_NAME_NAMESPACE = "namespace";
    @SerializedName(SERIALIZED_NAME_NAMESPACE)
    private String namespace;

    public V1alpha1SandboxSetSpecSpecDataSourceRef apiGroup(String apiGroup) {

        this.apiGroup = apiGroup;
        return this;
    }

    /**
     * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be
     * in the core API group. For any other third-party types, APIGroup is required.
     *
     * @return apiGroup
     **/
    @javax.annotation.Nullable
    @ApiModelProperty(
        value = "APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified"
            + " Kind must be in the core API group. For any other third-party types, APIGroup is required.")

    public String getApiGroup() {
        return apiGroup;
    }

    public void setApiGroup(String apiGroup) {
        this.apiGroup = apiGroup;
    }

    public V1alpha1SandboxSetSpecSpecDataSourceRef kind(String kind) {

        this.kind = kind;
        return this;
    }

    /**
     * Kind is the type of resource being referenced
     *
     * @return kind
     **/
    @ApiModelProperty(required = true, value = "Kind is the type of resource being referenced")

    public String getKind() {
        return kind;
    }

    public void setKind(String kind) {
        this.kind = kind;
    }

    public V1alpha1SandboxSetSpecSpecDataSourceRef name(String name) {

        this.name = name;
        return this;
    }

    /**
     * Name is the name of resource being referenced
     *
     * @return name
     **/
    @ApiModelProperty(required = true, value = "Name is the name of resource being referenced")

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public V1alpha1SandboxSetSpecSpecDataSourceRef namespace(String namespace) {

        this.namespace = namespace;
        return this;
    }

    /**
     * Namespace is the namespace of resource being referenced Note that when a namespace is specified, a
     * gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that
     * namespace&#39;s owner to accept the reference. See the ReferenceGrant documentation for details. (Alpha) This
     * field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
     *
     * @return namespace
     **/
    @javax.annotation.Nullable
    @ApiModelProperty(
        value = "Namespace is the namespace of resource being referenced Note that when a namespace is specified, a "
            + "gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that "
            + "namespace's owner to accept the reference. See the ReferenceGrant documentation for details. (Alpha) "
            + "This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.")

    public String getNamespace() {
        return namespace;
    }

    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        V1alpha1SandboxSetSpecSpecDataSourceRef v1alpha1SandboxSetSpecSpecDataSourceRef
            = (V1alpha1SandboxSetSpecSpecDataSourceRef)o;
        return Objects.equals(this.apiGroup, v1alpha1SandboxSetSpecSpecDataSourceRef.apiGroup) &&
            Objects.equals(this.kind, v1alpha1SandboxSetSpecSpecDataSourceRef.kind) &&
            Objects.equals(this.name, v1alpha1SandboxSetSpecSpecDataSourceRef.name) &&
            Objects.equals(this.namespace, v1alpha1SandboxSetSpecSpecDataSourceRef.namespace);
    }

    @Override
    public int hashCode() {
        return Objects.hash(apiGroup, kind, name, namespace);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class V1alpha1SandboxSetSpecSpecDataSourceRef {\n");
        sb.append("    apiGroup: ").append(toIndentedString(apiGroup)).append("\n");
        sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
        sb.append("    name: ").append(toIndentedString(name)).append("\n");
        sb.append("    namespace: ").append(toIndentedString(namespace)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }

}

